---
// Canvas-based animations for improved performance
---

<div id="canvas-container" class="fixed inset-0 pointer-events-none z-10">
  <canvas id="main-canvas" class="w-full h-full"></canvas>
</div>

<style>
  #canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 10;
  }
  
  #main-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  /* Hide canvas on mobile for better performance */
  @media (max-width: 768px) {
    #canvas-container {
      display: none;
    }
  }
</style>

<script>
  class CanvasAnimationSystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private particles: Particle[] = [];
    private cursorTrail: CursorPoint[] = [];
    private sparkles: Sparkle[] = [];
    private animationId: number | null = null;
    private lastTime = 0;
    private mouseX = 0;
    private mouseY = 0;
    private isHovering = false;
    private heroSection: HTMLElement | null = null;

    constructor() {
      this.canvas = document.getElementById('main-canvas') as HTMLCanvasElement;
      if (!this.canvas) return;
      
      this.ctx = this.canvas.getContext('2d')!;
      this.setupCanvas();
      this.setupEventListeners();
      this.createParticles();
      this.startAnimation();
    }

    private setupCanvas() {
      const resizeCanvas = () => {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      };

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }

    private setupEventListeners() {
      document.addEventListener('mousemove', (e) => {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        this.addCursorPoint(e.clientX, e.clientY);
      });

      document.addEventListener('mouseenter', () => {
        this.isHovering = true;
      });

      document.addEventListener('mouseleave', () => {
        this.isHovering = false;
      });

      document.addEventListener('click', (e) => {
        this.createSparkleBurst(e.clientX, e.clientY);
      });
    }

    private createParticles() {
      const particleCount = 20;
      for (let i = 0; i < particleCount; i++) {
        this.particles.push(new Particle(
          Math.random() * this.canvas.width,
          Math.random() * this.canvas.height,
          Math.random() * 2 + 0.5,
          Math.random() * 0.02 + 0.01,
          Math.random() * Math.PI * 2
        ));
      }
    }

    private addCursorPoint(x: number, y: number) {
      this.cursorTrail.push(new CursorPoint(x, y, 1));
      
      // Limit trail length
      if (this.cursorTrail.length > 15) {
        this.cursorTrail.shift();
      }
    }

    private createSparkleBurst(x: number, y: number) {
      const sparkleCount = 8;
      for (let i = 0; i < sparkleCount; i++) {
        const angle = (Math.PI * 2 * i) / sparkleCount;
        const velocity = Math.random() * 3 + 2;
        const vx = Math.cos(angle) * velocity;
        const vy = Math.sin(angle) * velocity;
        
        this.sparkles.push(new Sparkle(x, y, vx, vy));
      }
    }

    private update(deltaTime: number) {
      // Update particles
      this.particles.forEach(particle => {
        particle.update(deltaTime, this.canvas.width, this.canvas.height);
      });

      // Update cursor trail
      this.cursorTrail.forEach(point => {
        point.update(deltaTime);
      });

      // Update sparkles
      this.sparkles.forEach((sparkle, index) => {
        sparkle.update(deltaTime);
        if (sparkle.life <= 0) {
          this.sparkles.splice(index, 1);
        }
      });

      // Remove expired cursor trail points
      this.cursorTrail = this.cursorTrail.filter(point => point.life > 0);
    }

    private render() {
      // Clear canvas
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Render particles
      this.particles.forEach(particle => {
        particle.render(this.ctx);
      });

      // Render cursor trail
      this.cursorTrail.forEach((point, index) => {
        point.render(this.ctx, index);
      });

      // Render sparkles
      this.sparkles.forEach(sparkle => {
        sparkle.render(this.ctx);
      });

      // Render interactive effects when hovering
      if (this.isHovering) {
        this.renderHoverEffects();
      }
    }

    private renderHoverEffects() {
      // Create subtle glow around cursor
      const gradient = this.ctx.createRadialGradient(
        this.mouseX, this.mouseY, 0,
        this.mouseX, this.mouseY, 50
      );
      gradient.addColorStop(0, 'rgba(245, 155, 187, 0.1)');
      gradient.addColorStop(1, 'rgba(245, 155, 187, 0)');
      
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(this.mouseX - 50, this.mouseY - 50, 100, 100);
    }

    private animate = (currentTime: number) => {
      const deltaTime = currentTime - this.lastTime;
      this.lastTime = currentTime;

      this.update(deltaTime);
      this.render();

      this.animationId = requestAnimationFrame(this.animate);
    };

    private startAnimation() {
      this.animationId = requestAnimationFrame(this.animate);
    }

    public destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  class Particle {
    public x: number;
    public y: number;
    public size: number;
    public speed: number;
    public angle: number;
    public life: number = 1;
    private maxLife: number;

    constructor(x: number, y: number, size: number, speed: number, angle: number) {
      this.x = x;
      this.y = y;
      this.size = size;
      this.speed = speed;
      this.angle = angle;
      this.maxLife = Math.random() * 10000 + 5000; // 5-15 seconds
    }

    update(deltaTime: number, canvasWidth: number, canvasHeight: number) {
      // Move particle
      this.x += Math.cos(this.angle) * this.speed * deltaTime * 0.1;
      this.y += Math.sin(this.angle) * this.speed * deltaTime * 0.1;

      // Wrap around screen
      if (this.x < 0) this.x = canvasWidth;
      if (this.x > canvasWidth) this.x = 0;
      if (this.y < 0) this.y = canvasHeight;
      if (this.y > canvasHeight) this.y = 0;

      // Update life
      this.life -= deltaTime / this.maxLife;
      if (this.life <= 0) {
        this.life = 1;
        this.x = Math.random() * canvasWidth;
        this.y = Math.random() * canvasHeight;
      }
    }

    render(ctx: CanvasRenderingContext2D) {
      ctx.save();
      ctx.globalAlpha = this.life * 0.6;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  class CursorPoint {
    public x: number;
    public y: number;
    public life: number;
    private maxLife: number = 1;

    constructor(x: number, y: number, life: number) {
      this.x = x;
      this.y = y;
      this.life = life;
    }

    update(deltaTime: number) {
      this.life -= deltaTime * 0.003; // Fade out over time
    }

    render(ctx: CanvasRenderingContext2D, index: number) {
      const alpha = this.life * (0.8 - index * 0.05);
      const size = (this.life * 8) + (index * 2);

      ctx.save();
      ctx.globalAlpha = alpha;
      
      // Create gradient for glow effect
      const gradient = ctx.createRadialGradient(
        this.x, this.y, 0,
        this.x, this.y, size * 2
      );
      gradient.addColorStop(0, 'rgba(245, 155, 187, 1)');
      gradient.addColorStop(0.5, 'rgba(245, 155, 187, 0.6)');
      gradient.addColorStop(1, 'rgba(245, 155, 187, 0)');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, size * 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Add inner bright spot
      ctx.globalAlpha = alpha * 0.8;
      ctx.fillStyle = 'rgba(245, 155, 187, 1)';
      ctx.beginPath();
      ctx.arc(this.x, this.y, size * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  }

  class Sparkle {
    public x: number;
    public y: number;
    public vx: number;
    public vy: number;
    public life: number = 1;
    public size: number;
    private maxLife: number = 1000; // 1 second

    constructor(x: number, y: number, vx: number, vy: number) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.size = Math.random() * 3 + 2;
    }

    update(deltaTime: number) {
      this.x += this.vx * deltaTime * 0.1;
      this.y += this.vy * deltaTime * 0.1;
      this.life -= deltaTime / this.maxLife;
      
      // Apply gravity
      this.vy += 0.02 * deltaTime * 0.1;
    }

    render(ctx: CanvasRenderingContext2D) {
      ctx.save();
      ctx.globalAlpha = this.life;
      
      // Create sparkle effect with multiple layers
      const gradient = ctx.createRadialGradient(
        this.x, this.y, 0,
        this.x, this.y, this.size * 2
      );
      gradient.addColorStop(0, 'rgba(245, 155, 187, 1)');
      gradient.addColorStop(0.5, 'rgba(245, 155, 187, 0.6)');
      gradient.addColorStop(1, 'rgba(245, 155, 187, 0)');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Add bright center
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
  }

  // Initialize canvas animation system
  let canvasSystem: CanvasAnimationSystem | null = null;

  function initializeCanvasAnimations() {
    // Only initialize on desktop
    if (window.innerWidth > 768) {
      canvasSystem = new CanvasAnimationSystem();
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeCanvasAnimations);
  } else {
    initializeCanvasAnimations();
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (canvasSystem) {
      canvasSystem.destroy();
    }
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    if (canvasSystem && window.innerWidth <= 768) {
      canvasSystem.destroy();
      canvasSystem = null;
    } else if (!canvasSystem && window.innerWidth > 768) {
      initializeCanvasAnimations();
    }
  });
</script>
